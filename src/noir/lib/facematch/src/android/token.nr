use crate::constants::{APP_ATTEST_ENV_DEVELOPMENT, APP_ATTEST_ENV_PRODUCTION, APP_ID_MAX_LEN};
use super::constants::{
    INTEGRITY_TOKEN_MAX_LENGTH, JWS_HEADER_BASE64, JWS_HEADER_LENGTH, JWS_PAYLOAD_LENGTH,
    JWS_PAYLOAD_SEPARATOR, PLAY_INTEGRITY_PUBLIC_KEY_X, PLAY_INTEGRITY_PUBLIC_KEY_Y,
};
use base64::{BASE64_URL_DECODER, BASE64_URL_ENCODER};
use json_parser::JSON1kb;
use sig_check_ecdsa::verify_nist_p256_blackbox as verify_nist_p256;
use utils::find_subarray_index;
use utils::split_array;

// Fake integrity token to simulate a token meeting all criteria
global SAMPLE_INTEGRITY_TOKEN: str<623> = r#"{"requestDetails":{"requestPackageName":"com.package.name","timestampMillis":"1760262881732","nonce":"uU0nuZNNPgilLlLX2n2r-sSE7-N6U4DukIj3rOLvzek\u003d"},"appIntegrity":{"appRecognitionVerdict":"PLAY_RECOGNIZED","packageName":"com.package.name","certificateSha256Digest":["6a6a1474b5cbbb2b1aa57e0bc3"],"versionCode":"42"},"deviceIntegrity":{"deviceRecognitionVerdict":["MEETS_DEVICE_INTEGRITY","MEETS_STRONG_INTEGRITY"],"recentDeviceActivity":{"deviceActivityLevel":"LEVEL_3"},"deviceAttributes":{"sdkVersion":32}},"accountDetails":{"appLicensingVerdict":"LICENSED"},"environmentDetails":{"playProtectVerdict":"NO_ISSUES"}}"#;
// A real integrity token that was generated by the Play Integrity API
// Since it was generated on a local build, most criteria are not met
global REAL_INTEGRITY_TOKEN: str<782> = r#"{
  "requestDetails": {
    "requestPackageName": "app.zkpassport.zkpassport",
    "timestampMillis": "1760263715963",
    "nonce": "rnvbEXp7v8enazX3-sXja-nX1l1TYAMg-yk81yLffno\u003d"
  },
  "appIntegrity": {
    "appRecognitionVerdict": "UNRECOGNIZED_VERSION",
    "packageName": "app.zkpassport.zkpassport",
    "certificateSha256Digest": ["-sYXRdwJA3hvue3mKpYrOZ9zSPC7b4mbgzJmdZEDO5w"],
    "versionCode": "903"
  },
  "deviceIntegrity": {
    "deviceRecognitionVerdict": ["MEETS_DEVICE_INTEGRITY"],
    "recentDeviceActivity": {
      "deviceActivityLevel": "UNEVALUATED"
    },
    "deviceAttributes": {
      "sdkVersion": 34
    }
  },
  "accountDetails": {
    "appLicensingVerdict": "UNEVALUATED"
  },
  "environmentDetails": {
    "playProtectVerdict": "UNEVALUATED"
  }
}"#;
// The padding added at the end of the nonce: = (encoded as \u003d)
global NONCE_PADDING: [u8; 6] = [92, 117, 48, 48, 51, 100];

pub struct IntegrityTokenCheckResponse {
    pub timestamp: u64,
    pub environment: u8,
    pub nonce: [u8; 32],
}

pub fn parse_integrity_token(token: [u8; INTEGRITY_TOKEN_MAX_LENGTH]) -> JSON1kb {
    let mut formatted_token = [32; INTEGRITY_TOKEN_MAX_LENGTH];
    for i in 0..INTEGRITY_TOKEN_MAX_LENGTH {
        if token[i] != 0 {
            formatted_token[i] = token[i];
        }
    }
    let json = JSON1kb::parse_json(formatted_token);
    json
}

unconstrained fn unsafe_get_integrity_token_length(token: [u8; INTEGRITY_TOKEN_MAX_LENGTH]) -> u32 {
    let mut length = 0;
    for i in 0..INTEGRITY_TOKEN_MAX_LENGTH {
        if token[i] == 0 {
            length = i;
            break;
        }
    }
    length
}

pub fn get_integrity_token_length(token: [u8; INTEGRITY_TOKEN_MAX_LENGTH]) -> u32 {
    //Safety: Gets the token length from the token and then constrains that the rest
    // of bytes arrays are as expected
    let length = unsafe { unsafe_get_integrity_token_length(token) };
    assert(length > 0, "Invalid integrity token length");
    assert(length <= INTEGRITY_TOKEN_MAX_LENGTH, "Invalid integrity token length");
    for i in 0..INTEGRITY_TOKEN_MAX_LENGTH {
        if i >= length {
            assert(token[i] == 0, "The integrity token must be padded with 0s");
        }
    }
    length
}

fn convert_timestamp_string_to_u64(timestamp: BoundedVec<u8, 20>) -> u64 {
    let mut timestamp_u64: u64 = 0;
    for i in 0..20 {
        if i < timestamp.len() {
            // Convert the ASCII character to a number
            let digit = timestamp.get(i) - 0x30;
            timestamp_u64 = timestamp_u64 * 10 + digit as u64;
        }
    }
    timestamp_u64
}

fn decode_nonce(nonce: BoundedVec<u8, 64>) -> BoundedVec<u8, 32> {
    // The token signed by Play Integrity API contains \u003d rather than = directly
    // in the nonce, so we need to remove the padding as the parsing will fail otherwise
    let padding_index = find_subarray_index(NONCE_PADDING, nonce.storage());
    // If we found the padding, we remove it, otherwise it will use the entire nonce as is
    let nonce_without_padding = BoundedVec::from_parts(nonce.storage(), padding_index);
    // The nonce is a sha256 hash, so it is 32 bytes
    // Since we removed the padding, we use the decoder without padding
    let decoded_nonce: BoundedVec<u8, 32> = BASE64_URL_DECODER::decode_var(nonce_without_padding);
    decoded_nonce
}

/// Verify the integrity token from Play Integrity API
/// The integrity token is signed, so the signature can be verified
/// to make sure we can trust it.
/// Structure of the integrity token:
/// {
///   "requestDetails": {
///     "requestPackageName": "com.package.name",
///     "timestampMillis": "1760262881732",
///     "nonce": "aGVsbG8gd29scmQgdGhlcmU"
///   },
///   "appIntegrity": {
///     "appRecognitionVerdict": "PLAY_RECOGNIZED",
///     "packageName": "com.package.name",
///     "certificateSha256Digest": [
///       "6a6a1474b5cbbb2b1aa57e0bc3"
///     ],
///     "versionCode": "42"
///   },
///   "deviceIntegrity": {
///     "deviceRecognitionVerdict": [
///       "MEETS_DEVICE_INTEGRITY",
///       "MEETS_STRONG_INTEGRITY"
///     ],
///     "recentDeviceActivity": {
///       "deviceActivityLevel": "LEVEL_3"
///     },
///     "deviceAttributes": {
///      "sdkVersion": 32
///     }
///   },
///   "accountDetails": {
///     "appLicensingVerdict": "LICENSED"
///   },
///   "environmentDetails": {
///     "playProtectVerdict": "NO_ISSUES"
///   }
/// }
pub fn verify_integrity_token(
    token: JSON1kb,
    app_id: [u8; APP_ID_MAX_LEN],
    app_id_length: u32,
) -> IntegrityTokenCheckResponse {
    let request_details = token.get_object("requestDetails").unwrap();
    let request_package_name: BoundedVec<u8, APP_ID_MAX_LEN> =
        request_details.get_string("requestPackageName").unwrap();
    let timestamp_millis: BoundedVec<u8, 20> =
        request_details.get_string("timestampMillis").unwrap();
    let nonce: BoundedVec<u8, 64> = request_details.get_string("nonce").unwrap();

    let app_integrity = token.get_object("appIntegrity").unwrap();

    let app_recognition_verdict: BoundedVec<u8, 25> =
        app_integrity.get_string("appRecognitionVerdict").unwrap();
    // We only accept when the app was downloaded from the Google Play Store
    // and is recognized by Google as the bundle we originally signed and published
    // The possibles values are PLAY_RECOGNIZED, UNRECOGNIZED_VERSION and UNEVALUATED
    let pass_app_recognition_verdict =
        app_recognition_verdict == BoundedVec::from_array("PLAY_RECOGNIZED".as_bytes());

    let package_name: BoundedVec<u8, APP_ID_MAX_LEN> =
        app_integrity.get_string("packageName").unwrap();
    assert_eq(package_name, request_package_name, "Package name mismatch");
    assert_eq(
        package_name,
        BoundedVec::from_parts(app_id, app_id_length),
        "The package name in the token does not match the expected app id",
    );

    let device_integrity = token.get_object("deviceIntegrity").unwrap();
    let device_recognition_verdict =
        device_integrity.get_array("deviceRecognitionVerdict").unwrap();

    let device_recognition_verdict_len = device_recognition_verdict.get_length();
    let mut passes_device_recognition = false;
    // There are 3 possible device recognition verdicts
    // MEETS_DEVICE_INTEGRITY, MEETS_STRONG_INTEGRITY, MEETS_BASIC_INTEGRITY
    // We only consider MEETS_DEVICE_INTEGRITY and MEETS_STRONG_INTEGRITY
    // MEETS_BASIC_INTEGRITY does not give enough guarantee
    for i in 0..3 {
        if i < device_recognition_verdict_len {
            let device_recognition_verdict: BoundedVec<u8, 30> =
                device_recognition_verdict.get_string_from_array(i as Field).unwrap();
            if (
                device_recognition_verdict
                    == BoundedVec::from_array("MEETS_DEVICE_INTEGRITY".as_bytes())
            )
                | (
                    device_recognition_verdict
                        == BoundedVec::from_array("MEETS_STRONG_INTEGRITY".as_bytes())
                ) {
                passes_device_recognition = true;
            }
        }
    }

    // For now, we don't check the play protect verdict as this is not as important as other checks
    /*let environment_details = token.get_object("environmentDetails").unwrap();
    let play_protect_verdict: BoundedVec<u8, 30> = environment_details.get_string("playProtectVerdict").unwrap();
    let pass_play_protect_verdict = play_protect_verdict == BoundedVec::from_array("NO_ISSUES".as_bytes());*/

    let pass_all_checks = pass_app_recognition_verdict & passes_device_recognition;

    IntegrityTokenCheckResponse {
        // The timestamp is in milliseconds, so we divide by 1000 to get the seconds
        timestamp: convert_timestamp_string_to_u64(timestamp_millis) / 1000,
        // If all checks pass, we consider the environment to be production
        // Otherwise, we consider the environment to be development which is not accepted by verifiers
        // in production
        environment: if pass_all_checks {
            APP_ATTEST_ENV_PRODUCTION
        } else {
            APP_ATTEST_ENV_DEVELOPMENT
        },
        nonce: decode_nonce(nonce).storage(),
    }
}

fn concat_jws_header_and_token(
    token: [u8; INTEGRITY_TOKEN_MAX_LENGTH],
    token_len: u32,
) -> ([u8; JWS_PAYLOAD_LENGTH + JWS_HEADER_LENGTH + 1], u32) {
    let mut signed_payload = [0; JWS_PAYLOAD_LENGTH + JWS_HEADER_LENGTH + 1];
    for i in 0..JWS_HEADER_LENGTH {
        signed_payload[i] = JWS_HEADER_BASE64[i];
    }
    // Add the dot separator
    signed_payload[JWS_HEADER_LENGTH] = JWS_PAYLOAD_SEPARATOR;
    let token_base64: BoundedVec<u8, JWS_PAYLOAD_LENGTH> =
        BASE64_URL_ENCODER::encode_var(BoundedVec::from_parts(token, token_len));
    for i in (JWS_HEADER_LENGTH + 1)..(JWS_PAYLOAD_LENGTH + JWS_HEADER_LENGTH + 1) {
        let token_index = i - JWS_HEADER_LENGTH - 1;
        if token_index < token_base64.len() {
            signed_payload[i] = token_base64.get(token_index);
        }
    }
    (signed_payload, token_base64.len() + JWS_HEADER_LENGTH + 1)
}

pub fn verify_integrity_token_signature(
    token: [u8; INTEGRITY_TOKEN_MAX_LENGTH],
    public_key_x: [u8; 32],
    public_key_y: [u8; 32],
    signature: [u8; 64],
) -> bool {
    let token_len = get_integrity_token_length(token);
    // The actual signed payload is the concatenation of the JWS header and the token
    // i.e. <base64({"alg":"ES256"})>.<base64({token})>
    let (signed_payload, signed_payload_len) = concat_jws_header_and_token(token, token_len);
    let msg_hash = sha256::sha256_var(signed_payload, signed_payload_len as u64);
    let (signature_r, signature_s) = split_array(signature);
    verify_nist_p256(
        public_key_x,
        public_key_y,
        signature_r,
        signature_s,
        msg_hash,
    )
}

pub fn verify_nonce(nonce: [u8; 32], client_data_hash: [u8; 32], signature: [u8; 64]) -> bool {
    // The nonce is the sha256 hash of the concatenation of the client data hash and signature
    // i.e. sha256(<client_data_hash><signature>)
    let nonce_data = client_data_hash.concat(signature);
    let reconstructed_nonce = sha256::sha256_var(nonce_data, nonce_data.len() as u64);
    nonce == reconstructed_nonce
}

pub fn pad_token<let TOKEN_LEN: u32>(token: [u8; TOKEN_LEN]) -> [u8; INTEGRITY_TOKEN_MAX_LENGTH] {
    // Pad with 0s
    let mut padded_token = [0; INTEGRITY_TOKEN_MAX_LENGTH];
    for i in 0..TOKEN_LEN {
        padded_token[i] = token[i];
    }
    padded_token
}

#[test]
fn test_verify_integrity_token() {
    let token = parse_integrity_token(pad_token(SAMPLE_INTEGRITY_TOKEN.as_bytes()));
    let app_id: BoundedVec<u8, APP_ID_MAX_LEN> =
        BoundedVec::from_array("com.package.name".as_bytes());
    let app_id_length = 16;
    let response = verify_integrity_token(token, app_id.storage(), app_id_length);
    assert_eq(response.environment, APP_ATTEST_ENV_PRODUCTION);
    assert_eq(response.timestamp, 1760262881);
    let hash = sha256::sha256_var("hello world".as_bytes(), 11);
    assert_eq(response.nonce, hash);
}

#[test]
fn test_verify_integrity_token_signature() {
    let signature: [u8; 64] = [
        7, 43, 57, 49, 121, 201, 148, 129, 231, 214, 235, 238, 215, 58, 126, 91, 145, 164, 167, 248,
        241, 75, 202, 120, 86, 163, 100, 187, 171, 18, 246, 74, 81, 70, 212, 62, 131, 12, 221, 155,
        93, 77, 127, 194, 147, 189, 164, 120, 233, 155, 55, 158, 115, 201, 255, 102, 250, 115, 92,
        82, 121, 77, 77, 11,
    ];
    let verified = verify_integrity_token_signature(
        pad_token(REAL_INTEGRITY_TOKEN.as_bytes()),
        PLAY_INTEGRITY_PUBLIC_KEY_X,
        PLAY_INTEGRITY_PUBLIC_KEY_Y,
        signature,
    );
    assert(verified, "Failed to verify integrity token signature");
}
