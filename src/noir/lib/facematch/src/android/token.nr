use json_parser::JSON1kb;
use base64::{BASE64_DECODER, BASE64_URL_ENCODER};
use crate::constants::{APP_ATTEST_ENV_DEVELOPMENT, APP_ATTEST_ENV_PRODUCTION, APP_ID_MAX_LEN};
use utils::split_array;
use sig_check_ecdsa::verify_nist_p256_blackbox as verify_nist_p256;

// This is the public key used by Play Integrity to sign the integrity token
// It's a P256 key as the signing algorithm is ECDSA with SHA-256 using P-256 as the curve
// We hardcoded it here since it's not expected to change
global PLAY_INTEGRITY_PUBLIC_KEY_X: [u8; 32] = [
  107,  48, 114, 237, 199,  76, 241, 189,
   65,  24,  76,  66,  69, 105, 215, 118,
   99, 120,  95, 228, 115,  59, 132,  26,
  127, 164, 243, 248, 131, 236, 116,  92
];
global PLAY_INTEGRITY_PUBLIC_KEY_Y: [u8; 32] = [
  128,  65, 122,  29, 121, 206, 219, 126,
  163,  96,  28,  35,  13,  89,  99, 254,
   38, 211,   6, 124, 148,  77,   5,  49,
   23, 104, 193, 198, 191,  90,  73, 156
];

global INTEGRITY_TOKEN_MAX_LENGTH: u32 = 1024;
// Fake integrity token to simulate a token meeting all criteria
global SAMPLE_INTEGRITY_TOKEN: str<618> = "{\"requestDetails\":{\"requestPackageName\":\"com.package.name\",\"timestampMillis\":\"1760262881732\",\"nonce\":\"uU0nuZNNPgilLlLX2n2r+sSE7+N6U4DukIj3rOLvzek=\"},\"appIntegrity\":{\"appRecognitionVerdict\":\"PLAY_RECOGNIZED\",\"packageName\":\"com.package.name\",\"certificateSha256Digest\":[\"6a6a1474b5cbbb2b1aa57e0bc3\"],\"versionCode\":\"42\"},\"deviceIntegrity\":{\"deviceRecognitionVerdict\":[\"MEETS_DEVICE_INTEGRITY\",\"MEETS_STRONG_INTEGRITY\"],\"recentDeviceActivity\":{\"deviceActivityLevel\":\"LEVEL_3\"},\"deviceAttributes\":{\"sdkVersion\":32}},\"accountDetails\":{\"appLicensingVerdict\":\"LICENSED\"},\"environmentDetails\":{\"playProtectVerdict\":\"NO_ISSUES\"}}";
// A real integrity token that was generated by the Play Integrity API
// Since it was generated on local build, most criteria are not met
global REAL_INTEGRITY_TOKEN: str<782> = r#"{
  "requestDetails": {
    "requestPackageName": "app.zkpassport.zkpassport",
    "timestampMillis": "1760263715963",
    "nonce": "rnvbEXp7v8enazX3-sXja-nX1l1TYAMg-yk81yLffno\u003d"
  },
  "appIntegrity": {
    "appRecognitionVerdict": "UNRECOGNIZED_VERSION",
    "packageName": "app.zkpassport.zkpassport",
    "certificateSha256Digest": ["-sYXRdwJA3hvue3mKpYrOZ9zSPC7b4mbgzJmdZEDO5w"],
    "versionCode": "903"
  },
  "deviceIntegrity": {
    "deviceRecognitionVerdict": ["MEETS_DEVICE_INTEGRITY"],
    "recentDeviceActivity": {
      "deviceActivityLevel": "UNEVALUATED"
    },
    "deviceAttributes": {
      "sdkVersion": 34
    }
  },
  "accountDetails": {
    "appLicensingVerdict": "UNEVALUATED"
  },
  "environmentDetails": {
    "playProtectVerdict": "UNEVALUATED"
  }
}"#;
// global JWS_HEADER: str<15> = "{\"alg\":\"ES256\"}";
// Base64 encoded JWS header: eyJhbGciOiJFUzI1NiJ9
global JWS_HEADER_LENGTH: u32 = 20;
global JWS_HEADER_BASE64: [u8; 20] = [101,121,74,104,98,71,99,105,79,105,74,70,85,122,73,49,78,105,74,57];
// Base64 encoded JWS payload separator: .
global JWS_PAYLOAD_SEPARATOR: u8 = 46;
global JWS_PAYLOAD_LENGTH: u32 = 1366;


pub struct IntegrityTokenCheckResponse {
    timestamp: u64,
    environment: u8,
    nonce: [u8; 32],
}

pub fn parse_integrity_token(token: [u8; INTEGRITY_TOKEN_MAX_LENGTH]) -> JSON1kb {
    let mut formatted_token = [32; INTEGRITY_TOKEN_MAX_LENGTH];
    for i in 0..INTEGRITY_TOKEN_MAX_LENGTH {
        if token[i] != 0 {
            formatted_token[i] = token[i];
        }
    }
    let json = JSON1kb::parse_json(formatted_token);
    json
}

unconstrained fn unsafe_get_integrity_token_length(token: [u8; INTEGRITY_TOKEN_MAX_LENGTH]) -> u32 {
    let mut length = 0;
    for i in 0..INTEGRITY_TOKEN_MAX_LENGTH {
        if token[i] == 0 {
            length = i;
            break;
        }
    }
    length
}

pub fn get_integrity_token_length(token: [u8; INTEGRITY_TOKEN_MAX_LENGTH]) -> u32 {
    //Safety: Gets the token length from the token and then constrains that the rest
    // of bytes arrays are as expected
    let length = unsafe { unsafe_get_integrity_token_length(token) };
    assert(length > 0, "Invalid integrity token length");
    assert(length <= INTEGRITY_TOKEN_MAX_LENGTH, "Invalid integrity token length");
    for i in 0..INTEGRITY_TOKEN_MAX_LENGTH {
        if i >= length {
            assert(token[i] == 0, "The integrity token must be padded with 0s");
        }
    }
    length
}

fn convert_timestamp_string_to_u64(timestamp: BoundedVec<u8, 20>) -> u64 {
    let mut timestamp_u64: u64 = 0;
    for i in 0..20 {
        if i < timestamp.len() {
            // Convert the ASCII character to a number
            let digit = timestamp.get(i) - 0x30;
            timestamp_u64 = timestamp_u64 * 10 + digit as u64;
        }
    }
    timestamp_u64
}

fn decode_nonce(nonce: BoundedVec<u8, 64>) -> BoundedVec<u8, 32> {
    // The nonce is a sha256 hash, so it is 32 bytes
    let decoded_nonce: BoundedVec<u8, 32> = BASE64_DECODER::decode_var(nonce);
    decoded_nonce
}

/// Verify the integrity token from Play Integrity API
/// The integrity token is signed, so the signature can be verified
/// to make sure we can trust it.
/// Structure of the integrity token:
/// {
///   "requestDetails": {
///     "requestPackageName": "com.package.name",
///     "timestampMillis": "1760262881732",
///     "nonce": "aGVsbG8gd29scmQgdGhlcmU"
///   },
///   "appIntegrity": {
///     "appRecognitionVerdict": "PLAY_RECOGNIZED",
///     "packageName": "com.package.name",
///     "certificateSha256Digest": [
///       "6a6a1474b5cbbb2b1aa57e0bc3"
///     ],
///     "versionCode": "42"
///   },
///   "deviceIntegrity": {
///     "deviceRecognitionVerdict": [
///       "MEETS_DEVICE_INTEGRITY",
///       "MEETS_STRONG_INTEGRITY"
///     ],
///     "recentDeviceActivity": {
///       "deviceActivityLevel": "LEVEL_3"
///     },
///     "deviceAttributes": {
///      "sdkVersion": 32
///     }
///   },
///   "accountDetails": {
///     "appLicensingVerdict": "LICENSED"
///   },
///   "environmentDetails": {
///     "playProtectVerdict": "NO_ISSUES"
///   }
/// }
pub fn verify_integrity_token(token: JSON1kb, app_id: [u8; APP_ID_MAX_LEN], app_id_length: u32) -> IntegrityTokenCheckResponse {
    let request_details = token.get_object("requestDetails").unwrap();
    let request_package_name: BoundedVec<u8, APP_ID_MAX_LEN> = request_details.get_string("requestPackageName").unwrap();
    let timestamp_millis: BoundedVec<u8, 20> = request_details.get_string("timestampMillis").unwrap();
    let nonce: BoundedVec<u8, 64> = request_details.get_string("nonce").unwrap();

    let app_integrity = token.get_object("appIntegrity").unwrap();

    let app_recognition_verdict: BoundedVec<u8, 25> = app_integrity.get_string("appRecognitionVerdict").unwrap();
    // We only accept when the app was downloaded from the Google Play Store 
    // and is recognized by Google as the bundle we originally signed and published
    // The possibles values are PLAY_RECOGNIZED, UNRECOGNIZED_VERSION and UNEVALUATED
    let pass_app_recognition_verdict = app_recognition_verdict == BoundedVec::from_array("PLAY_RECOGNIZED".as_bytes());
    
    let package_name: BoundedVec<u8, APP_ID_MAX_LEN> = app_integrity.get_string("packageName").unwrap();
    assert_eq(package_name, request_package_name, "Package name mismatch");
    assert_eq(package_name, BoundedVec::from_parts(app_id, app_id_length), "The package name in the token does not match the expected app id");

    let device_integrity = token.get_object("deviceIntegrity").unwrap();
    let device_recognition_verdict = device_integrity.get_array("deviceRecognitionVerdict").unwrap();

    let device_recognition_verdict_len = device_recognition_verdict.get_length();
    let mut passes_device_recognition = false;
    // There are 3 possible device recognition verdicts
    // MEETS_DEVICE_INTEGRITY, MEETS_STRONG_INTEGRITY, MEETS_BASIC_INTEGRITY
    // We only consider MEETS_DEVICE_INTEGRITY and MEETS_STRONG_INTEGRITY
    // MEETS_BASIC_INTEGRITY does not give enough guarantee
    for i in 0..3 {
        if i < device_recognition_verdict_len {
            let device_recognition_verdict: BoundedVec<u8, 30> = device_recognition_verdict.get_string_from_array(i as Field).unwrap();
            if (device_recognition_verdict == BoundedVec::from_array("MEETS_DEVICE_INTEGRITY".as_bytes())) | 
            (device_recognition_verdict == BoundedVec::from_array("MEETS_STRONG_INTEGRITY".as_bytes())) {
                passes_device_recognition = true;
            }
        }
    }

    // For now, we don't check the play protect verdict as this is not as important as other checks
    /*let environment_details = token.get_object("environmentDetails").unwrap();
    let play_protect_verdict: BoundedVec<u8, 30> = environment_details.get_string("playProtectVerdict").unwrap();
    let pass_play_protect_verdict = play_protect_verdict == BoundedVec::from_array("NO_ISSUES".as_bytes());*/

    let pass_all_checks = pass_app_recognition_verdict & passes_device_recognition;

    IntegrityTokenCheckResponse {
        // The timestamp is in milliseconds, so we divide by 1000 to get the seconds
        timestamp: convert_timestamp_string_to_u64(timestamp_millis) / 1000,
        // If all checks pass, we consider the environment to be production
        // Otherwise, we consider the environment to be development which is not accepted by verifiers
        // in production
        environment: if pass_all_checks { APP_ATTEST_ENV_PRODUCTION } else { APP_ATTEST_ENV_DEVELOPMENT },
        nonce: decode_nonce(nonce).storage(),
    }
}

fn concat_jws_header_and_token(token: [u8; INTEGRITY_TOKEN_MAX_LENGTH], token_len: u32) -> ([u8; JWS_PAYLOAD_LENGTH + JWS_HEADER_LENGTH + 1], u32) {
    let mut signed_payload = [0; JWS_PAYLOAD_LENGTH + JWS_HEADER_LENGTH + 1];
    for i in 0..JWS_HEADER_LENGTH {
        signed_payload[i] = JWS_HEADER_BASE64[i];
    }
    // Add the dot separator
    signed_payload[JWS_HEADER_LENGTH] = JWS_PAYLOAD_SEPARATOR;
    let token_base64: BoundedVec<u8, JWS_PAYLOAD_LENGTH> = BASE64_URL_ENCODER::encode_var(BoundedVec::from_parts(token, token_len));
    for i in (JWS_HEADER_LENGTH + 1)..(JWS_PAYLOAD_LENGTH + JWS_HEADER_LENGTH + 1) {
        let token_index = i - JWS_HEADER_LENGTH - 1;
        if token_index < token_base64.len() {
            signed_payload[i] = token_base64.get(token_index);
        }
    }
    (signed_payload, token_base64.len() + JWS_HEADER_LENGTH + 1)
}

pub fn verify_integrity_token_signature(token: [u8; INTEGRITY_TOKEN_MAX_LENGTH], signature: [u8; 64]) -> bool {
    let token_len = get_integrity_token_length(token);
    let (signed_payload, signed_payload_len) = concat_jws_header_and_token(token, token_len);  
    let msg_hash =  sha256::sha256_var(signed_payload, signed_payload_len as u64);
    let (signature_r, signature_s) = split_array(signature);
    verify_nist_p256(PLAY_INTEGRITY_PUBLIC_KEY_X, PLAY_INTEGRITY_PUBLIC_KEY_Y, signature_r, signature_s, msg_hash)
}

fn pad_token<let TOKEN_LEN: u32>(token: [u8; TOKEN_LEN]) -> [u8; INTEGRITY_TOKEN_MAX_LENGTH] {
    // Pad with 0s
    let mut padded_token = [0; INTEGRITY_TOKEN_MAX_LENGTH];
    for i in 0..TOKEN_LEN {
        padded_token[i] = token[i];
    }
    padded_token
}

#[test]
fn test_verify_integrity_token() {
    let token = parse_integrity_token(pad_token(SAMPLE_INTEGRITY_TOKEN.as_bytes()));
    let app_id: BoundedVec<u8, APP_ID_MAX_LEN> = BoundedVec::from_array("com.package.name".as_bytes());
    let app_id_length = 16;
    let response = verify_integrity_token(token, app_id.storage(), app_id_length);
    assert_eq(response.environment, APP_ATTEST_ENV_PRODUCTION);
    assert_eq(response.timestamp, 1760262881);
    let hash = sha256::sha256_var("hello world".as_bytes(), 11);
    assert_eq(response.nonce, hash);
}

#[test]
fn test_verify_integrity_token_signature() {
    let signature: [u8; 64] = [
        7, 43, 57, 49, 121, 201, 148, 129, 231, 214, 235, 238, 215, 58, 126, 91, 145, 164,
        167, 248, 241, 75, 202, 120, 86, 163, 100, 187, 171, 18, 246, 74, 81, 70, 212, 62,
        131, 12, 221, 155, 93, 77, 127, 194, 147, 189, 164, 120, 233, 155, 55, 158, 115,
        201, 255, 102, 250, 115, 92, 82, 121, 77, 77, 11
    ];
    let verified = verify_integrity_token_signature(pad_token(REAL_INTEGRITY_TOKEN.as_bytes()), signature);
    assert(verified, "Failed to verify integrity token signature");
}